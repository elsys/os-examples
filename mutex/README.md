## pthread_mutex_trylock

**pthread_mutex_trylock** е подобна на **pthread_mutex_lock**.

Основната разлика между двете функции е, че **pthread_mutex_lock** блокира изпълнението на нишката, ако този мютекс в момента е заключен. От друга страна, **pthread_mutex_trylock** не блокира, а връща просто специална стойност като резултат - **EBUSY** .  Това позволява на нишката да извършва друга работа, вместо да чака. 

### Как се използва:


```c
if (pthread_mutex_trylock(&demoMutex) == 0) {
    // Достъп до споделени данни

    // Трябва да отключим мютекса само и единствено ако сме го заключили
    pthread_mutex_unlock(&demoMutex)
}
else {
    // Правим нещо друго, което не използва споделени данни
}

```

**Важно е**:
* Да използваме споделени данни само и единствено ако trylock върне 0
* Да отключим мютекса само и единствено ако сме го заключили  


### Как не се използва:

Долният код постига подобна функционалност на **pthread_mutex_lock**, но използва busy waiting - т.е. изпълнява се цикъла непрекъснато, без да има нужда от него

```c
while (pthread_mutex_trylock(&demoMutex) != 0) {
    // Достъп до споделени данни
}
```

